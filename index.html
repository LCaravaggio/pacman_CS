<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pac-Quiz (simulación)</title>
<style>
  :root{
    --tile:28px;
    --cols:19;
    --rows:13;
    --width: calc(var(--cols) * var(--tile));
    --height: calc(var(--rows) * var(--tile));
  }
  body{ 
    display:flex; flex-direction:column; align-items:center; gap:12px;
    background:#000; color:#fff; font-family:system-ui,Segoe UI,Roboto,Arial;
    min-height:100vh; margin:0; padding:20px;
  }
  h1{ margin:0; font-size:20px; color:#ffeb3b; text-shadow:0 0 8px #ffeb3b66}
  #gameWrap{ display:flex; gap:14px; align-items:flex-start;}
  canvas{ background:#000; image-rendering:pixelated; border:6px solid #222; box-shadow:0 0 20px #000 inset;}
  #hud{ width:260px; font-size:14px; }
  .panel{ background:#111; padding:10px; border-radius:8px; box-shadow:0 6px 18px #000; }
  .info{ margin-bottom:8px; color:#ddd;}
  .controls{ font-size:13px; color:#bbb; }
  .small{ font-size:12px; color:#9e9e9e;}
  .pill{ display:inline-block; padding:6px 8px; background:#222; border-radius:6px; margin:4px 0; color:#fff;}
  footer{ margin-top:12px; color:#9e9e9e; font-size:13px;}
</style>
</head>
<body>
  <h1>Pac-Quiz — movimiento con flechas • 5 preguntas</h1>
  <div id="gameWrap">
    <canvas id="game" width="calc(var(--cols) * var(--tile))" height="calc(var(--rows) * var(--tile))" style="width:var(--width);height:var(--height)"></canvas>
    <div id="hud" class="panel">
      <div class="info"><strong>Puntos:</strong> <span id="score">0</span></div>
      <div class="info"><strong>Preguntas pendientes:</strong> <span id="remaining">5</span></div>
      <div class="controls">
        <div class="small">Controles: <span class="pill">Flechas</span></div>
        <hr style="border:none;border-top:1px solid #222;margin:8px 0">
        <div><strong>Preguntas (se muestran al recoger):</strong></div>
        <ol class="small" id="qList">
          <li>¿Cómo se forman las cataratas?</li>
          <li>Mencioná tres recursos de la Argentina</li>
          <li>¿Qué diferencia hay entre el agua dulce y la salada?</li>
          <li>¿Cómo se llama el mar que bordea la Argentina?</li>
          <li>Decime tres cosas para las que sirve el agua en la sociedad</li>
        </ol>
      </div>
    </div>
  </div>

<script>
/*
  Pac-Quiz: simple grid-based pacman simulation.
  - Arrow keys to move.
  - 5 special pellets show an alert with the questions supplied by the user.
  - Small ghosts move randomly. Collision resets player to start.
*/

// --------- Configuration ----------
const TILE = 28;            // px
const COLS = 19;
const ROWS = 13;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;

const scoreEl = document.getElementById('score');
const remainingEl = document.getElementById('remaining');

const QUESTIONS = [
  "¿Cómo se forman las cataratas?",
  "Mencioná tres recursos de la Argentina",
  "¿Qué diferencia hay entre el agua dulce y la salada?",
  "¿Cómo se llama el mar que bordea la Argentina?",
  "Decime tres cosas para las que sirve el agua en la sociedad"
];

// map legend:
// 0 = empty / corridor
// 1 = wall
// 2 = pellet (small dot)
// 3 = question pellet (special)
let map = [
  // 19 columns each row
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
  [1,2,1,2,1,2,1,1,1,2,1,1,1,2,1,2,1,2,1],
  [1,3,1,2,2,2,2,3,1,2,1,3,2,2,2,2,1,3,1],
  [1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1],
  [1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
  [1,1,1,2,1,1,1,1,1,0,1,1,1,1,1,2,1,1,1],
  [1,2,2,2,2,2,2,2,1,2,1,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1],
  [1,2,1,3,1,2,1,2,2,2,2,2,1,2,1,3,1,2,1],
  [1,2,2,2,1,2,2,2,1,1,1,2,2,2,2,2,2,2,1],
  [1,2,1,2,1,1,1,2,2,3,2,2,1,1,1,2,1,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Convert 0 tiles to pellets to make corridor consistent (or keep as empty)
for(let r=0;r<ROWS;r++){
  for(let c=0;c<COLS;c++){
    if(map[r][c] === 0) map[r][c] = 2;
  }
}

// Player state
const player = {
  x: 1, y: 1,
  dir: {x:0,y:0}, // current movement
  nextDir: {x:0,y:0},
  radius: TILE*0.42,
  mouth: 0.2 // mouth openness 0..0.5
};

// Score & questions
let score = 0;
let remainingQuestions = QUESTIONS.length;
let collected = new Array(QUESTIONS.length).fill(false);

// Ghosts (simple)
const ghosts = [
  {x: 9, y: 5, color:'#ff6b6b', dir:{x:1,y:0}, speed:0.12},
  {x: 9, y: 7, color:'#6b8cff', dir:{x:-1,y:0}, speed:0.10}
];

// Helper
function tileIsWall(r,c){ return map[r] && map[r][c] === 1; }
function tileIsPellet(r,c){ return map[r] && (map[r][c] === 2); }
function tileIsQuestion(r,c){ return map[r] && (map[r][c] === 3); }

// keyboard
window.addEventListener('keydown', e=>{
  const k = e.key;
  if(k === 'ArrowLeft') player.nextDir = {x:-1,y:0};
  if(k === 'ArrowRight') player.nextDir = {x:1,y:0};
  if(k === 'ArrowUp') player.nextDir = {x:0,y:-1};
  if(k === 'ArrowDown') player.nextDir = {x:0,y:1};
});

// Game loop
let last = 0;
let accumulator = 0;
function loop(ts){
  if(!last) last = ts;
  const dt = (ts - last) / 1000;
  last = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Update
function update(dt){
  // Move player smoothly tile-based
  // Attempt to change dir if possible
  if(canMove(player.x + player.nextDir.x, player.y + player.nextDir.y)){
    player.dir = {...player.nextDir};
  }
  // step movement: tiny increments per frame so it's smooth
  const speed = 6.2 * dt; // tiles per second scaled
  // Try to move in current dir
  if(canMove(player.x + player.dir.x*speed, player.y + player.dir.y*speed)){
    player.x += player.dir.x * speed;
    player.y += player.dir.y * speed;
  } else {
    // stop when hitting wall
    player.dir = {x:0,y:0};
  }

  // Eat pellet when centered in tile
  const px = Math.round(player.x);
  const py = Math.round(player.y);
  if(tileIsPellet(py,px)){
    map[py][px] = 0;
    score += 10;
    scoreEl.textContent = score;
  }
  if(tileIsQuestion(py,px)){
    // Find which question index this tile corresponds to
    // We'll mark it collected and replace tile with 0
    // Find Nth question tile order to map to QUESTIONS array
    const qIndex = questionIndexAt(py, px);
    if(qIndex !== -1 && !collected[qIndex]){
      collected[qIndex] = true;
      map[py][px] = 0;
      remainingQuestions--;
      remainingEl.textContent = remainingQuestions;
      // show alert with question
      setTimeout(()=> {
        alert("Pregunta:\n\n" + QUESTIONS[qIndex]);
      }, 10);
      score += 50;
      scoreEl.textContent = score;
    }
  }

  // Ghost movement (random walking within corridors)
  ghosts.forEach(g=>{
    // Move ghost
    const ghostSpeed = g.speed; // tiles per second
    // pick direction occasionally
    if(Math.random() < 0.02){
      // choose random valid direction
      const options = [];
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>{
        const nx = Math.round(g.x + d[0]);
        const ny = Math.round(g.y + d[1]);
        if(!tileIsWall(ny,nx)) options.push({x:d[0], y:d[1]});
      });
      if(options.length) g.dir = options[Math.floor(Math.random()*options.length)];
    }
    // attempt move
    if(!tileIsWall(Math.round(g.y + g.dir.y * ghostSpeed), Math.round(g.x + g.dir.x * ghostSpeed))){
      g.x += g.dir.x * ghostSpeed;
      g.y += g.dir.y * ghostSpeed;
    } else {
      // reverse or choose new
      g.dir = {x:-g.dir.x, y:-g.dir.y};
    }

    // collision with player? check distance
    const dx = (g.x - player.x);
    const dy = (g.y - player.y);
    if(Math.hypot(dx,dy) < 0.7){
      // reset player position
      player.x = 1;
      player.y = 1;
      player.dir = {x:0,y:0};
      player.nextDir = {x:0,y:0};
      // small penalty
      score = Math.max(0, score - 30);
      scoreEl.textContent = score;
    }
  });

  // animate mouth
  player.mouth += dt * 3;
  if(player.mouth > 0.6) player.mouth = 0.0;
}

// Can move to fractional coords? Check center of destination tile is not wall.
function canMove(nx, ny){
  // we'll test collision with walls using the center of the pacman ghost
  const cx = nx;
  const cy = ny;
  // ensure inside grid
  if(cx < 0 || cy < 0 || cx >= COLS || cy >= ROWS) return false;
  // check the four corners of bounding box small radius
  const checkOffsets = [
    {x: -0.3, y:-0.3},
    {x: 0.3,  y:-0.3},
    {x: -0.3, y:0.3},
    {x: 0.3,  y:0.3}
  ];
  for(const off of checkOffsets){
    const tx = Math.floor(cx + off.x + 0.5);
    const ty = Math.floor(cy + off.y + 0.5);
    if(map[ty] && map[ty][tx] === 1) return false;
  }
  return true;
}

// Determine index of question pellet at tile (py,px) by scanning map's question tiles in reading order
function questionIndexAt(py, px){
  let idx = -1, count = 0;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(map[r][c] === 3){
        if(r === py && c === px){
          idx = count;
          return idx;
        }
        count++;
      }
    }
  }
  // It's possible map was mutated; if not found in current map, fallback to find original positions (we stored original above).
  // To make it robust, we will reconstruct original positions by scanning the original layout declared in source:
  // For simplicity, if not found, map indices 0..QUESTIONS.length-1 in order of (4th row, etc).
  return idx;
}

// Drawing
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // draw map: walls and pellets
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const x = c * TILE;
      const y = r * TILE;
      const cell = map[r][c];
      if(cell === 1){
        // wall
        ctx.fillStyle = '#001d3d';
        ctx.fillRect(x, y, TILE, TILE);
        // small bevel
        ctx.strokeStyle = '#003366';
        ctx.strokeRect(x+1, y+1, TILE-2, TILE-2);
      } else {
        // corridor - black already
        // pellets
        if(cell === 2){
          ctx.fillStyle = '#ffd54f';
          const px = x + TILE/2;
          const py = y + TILE/2;
          ctx.beginPath();
          ctx.arc(px, py, TILE*0.08, 0, Math.PI*2);
          ctx.fill();
        } else if(cell === 3){
          // question pellet (bigger and blue)
          ctx.fillStyle = '#4dd0e1';
          const px = x + TILE/2;
          const py = y + TILE/2;
          ctx.beginPath();
          ctx.arc(px, py, TILE*0.28, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#002';
          ctx.font = `${TILE*0.28}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('?', px, py+1);
        }
      }
    }
  }

  // draw ghosts
  ghosts.forEach(g=>{
    const gx = g.x * TILE + TILE/2;
    const gy = g.y * TILE + TILE/2;
    // body
    ctx.save();
    ctx.translate(gx, gy);
    ctx.beginPath();
    ctx.fillStyle = g.color;
    ctx.arc(0, -TILE*0.15, TILE*0.36, Math.PI, 0, false);
    ctx.rect(-TILE*0.36, -TILE*0.15, TILE*0.72, TILE*0.36 + TILE*0.15);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.ellipse(-TILE*0.13, -TILE*0.05, TILE*0.08, TILE*0.12, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(TILE*0.13, -TILE*0.05, TILE*0.08, TILE*0.12, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(-TILE*0.13, -TILE*0.02, TILE*0.03, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(TILE*0.13, -TILE*0.02, TILE*0.03, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  });

  // draw player (Pac-Man)
  const px = player.x * TILE + TILE/2;
  const py = player.y * TILE + TILE/2;
  // determine direction angle
  let angle = 0;
  if(player.dir.x === -1) angle = Math.PI;
  else if(player.dir.x === 1) angle = 0;
  else if(player.dir.y === -1) angle = -Math.PI/2;
  else if(player.dir.y === 1) angle = Math.PI/2;

  const mouthOpen = 0.25 + Math.abs(Math.sin(player.mouth)) * 0.25;
  const start = mouthOpen * Math.PI;
  const end = -mouthOpen * Math.PI;

  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.fillStyle = '#ffeb3b';
  ctx.moveTo(0,0);
  ctx.arc(0,0, player.radius, start, end, false);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}
</script>

<footer class="small">Hecho para GitHub Pages — archivo único (index.html). ¡Disfrutalo!</footer>
</body>
</html>
